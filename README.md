# Smart Search & Information Retrieval System

A simplified search engine implementation with **Web UI** demonstrating the application of core data structures and algorithms: **Tries**, **B+ Trees**, **Graph Algorithms (PageRank)**, and **Merge Sort**.

## Project Structure

```
Project/
├── data/                    # Directory containing HTML/text documents (generated by data_gen.py)
├── structures/              # Core data structure implementations
│   ├── __init__.py
│   ├── trie.py             # Trie for autocomplete functionality
│   ├── b_plus_tree.py      # B+ Tree for document indexing
│   └── graph.py            # Graph for PageRank/relevance modeling
├── utils/                   # Utility functions
│   ├── __init__.py
│   └── sorter.py           # Merge sort implementation
├── templates/               # Flask HTML templates
│   └── index.html          # Main search interface
├── static/                  # Static files (CSS, JavaScript)
│   ├── style.css           # Modern Google-like styling
│   └── script.js           # Live autocomplete and search logic
├── data_gen.py             # Script to generate dummy HTML/text files
├── engine.py               # Main search engine logic
├── app.py                  # Flask web application
├── main.py                 # CLI user interface (alternative)
├── requirements.txt        # Python dependencies
└── README.md               # This file
```

## Features

### 1. **Trie (Autocomplete Engine)**
- Efficient prefix matching
- Fast word suggestions based on partial input (top 5 results)
- Case-insensitive matching
- **Live autocomplete** in web UI with real-time suggestions

### 2. **B+ Tree (Storage Index)**
- In-memory B+ Tree implementation
- Stores document metadata (doc_id, title, url, snippet)
- Differentiates between Internal Nodes (indexes) and Leaf Nodes (data holders)
- Efficient search and insertion operations

### 3. **Graph (Relevance Modeling)**
- DocumentGraph using adjacency list representation
- Directed edges representing document citations
- PageRank algorithm for calculating authority scores
- Authority scores contribute to document ranking

### 4. **Merge Sort (Ranking)**
- Classic divide-and-conquer sorting algorithm
- Sorts search results by relevance score (descending order)
- O(n log n) time complexity

### 5. **Search Engine**
- Tokenizes and indexes documents from HTML/text files
- Builds inverted index for fast term lookup
- Calculates relevance scores: **Term Frequency + Authority Score**
- Ranks results using merge sort
- Generates snippets highlighting query terms

### 6. **Web Interface (Flask)**
- Modern Google-like search interface
- **Live autocomplete** with real-time suggestions as you type
- Responsive design with clean UI
- RESTful API endpoints for search and autocomplete
- Keyboard navigation support (arrow keys, enter, escape)

## Setup Instructions

### Step 1: Install Dependencies

Install Flask (the only external dependency):

```bash
pip3 install -r requirements.txt
```

Or install Flask directly:

```bash
pip3 install Flask
```

### Step 2: Generate Data Files

Run the data generation script to create dummy HTML/text files:

```bash
python3 data_gen.py
```

This will create 10 files (mix of HTML and text) in the `data/` directory with Computer Science content.

### Step 3: Run the Web Application

Start the Flask web server:

```bash
python3 app.py
```

The server will start on `http://localhost:5000`. Open this URL in your web browser to use the search engine.

### Alternative: CLI Interface

You can also use the command-line interface:

```bash
python3 main.py
```

## Usage

### Web Interface

1. **Open the application** in your browser at `http://localhost:5000`
2. **Type in the search bar** - you'll see live autocomplete suggestions appear as you type
3. **Select a suggestion** by clicking it or using arrow keys + Enter
4. **View ranked results** with title, URL, snippet, and relevance score
5. **Click on results** to view the full document

**Features:**
- **Live Autocomplete**: Suggestions appear in real-time as you type (debounced for performance)
- **Keyboard Navigation**: Use arrow keys to navigate suggestions, Enter to select, Escape to close
- **Modern UI**: Clean, Google-like interface with responsive design

### CLI Interface (Alternative)

The CLI provides three main options:

### [1] Search
Enter a search query (single word). The engine will:
- Find all documents containing the query term
- Calculate relevance scores (TF + Authority)
- Rank results using merge sort
- Display results with scores and metadata

**Example:**
```
Enter search query: trees
```

### [2] Autocomplete
Enter a prefix to get word suggestions from the indexed vocabulary.

**Example:**
```
Enter prefix: tri
```

### [3] Exit
Exit the application.

## How It Works

### Initialization Process

1. **Document Loading**: Reads all `.txt` and `.html` files from the `data/` directory
2. **Text Extraction**: Extracts plain text from HTML files (removes tags)
3. **Tokenization**: Breaks text into words (lowercase, alphanumeric)
4. **Trie Building**: Inserts all unique words into the Trie
5. **B+ Tree Indexing**: Stores document metadata (doc_id, title, url, snippet)
6. **Inverted Index**: Maps words to sets of document IDs
7. **Citation Generation**: Randomly generates citations between documents
8. **PageRank Calculation**: Computes authority scores for all documents

### Search Process

1. **Query Processing**: Tokenizes the search query
2. **Document Retrieval**: Uses inverted index to find matching documents
3. **Score Calculation**: For each document:
   - **Term Frequency (TF)**: Normalized frequency of the query term
   - **Authority Score**: PageRank score from the document graph
   - **Combined Score**: TF + Authority
4. **Ranking**: Sorts results using merge sort (descending by score)
5. **Result Display**: Shows ranked results with metadata

## Technical Details

### Data Structures

- **Trie**: O(m) search time where m is the length of the prefix
- **B+ Tree**: O(log n) search and insertion time
- **Graph**: O(V + E) PageRank calculation with iterative algorithm
- **Merge Sort**: O(n log n) sorting time

### Scoring Formula

```
Relevance Score = Term Frequency + Authority Score
```

Where:
- **Term Frequency**: `(term_count_in_doc) / (total_words_in_doc)`
- **Authority Score**: PageRank value from the document citation graph

## Requirements

- Python 3.6 or higher
- Flask 3.0.0+ (for web interface)
- All core data structures implemented from scratch (no external libraries for Trie, B+ Tree, Graph, or Merge Sort)

## Notes

- The search engine processes single-word queries
- Document citations are randomly generated during initialization
- All data structures are implemented from scratch (no external libraries)
- The system is case-insensitive for search queries

## API Endpoints

### POST `/autocomplete`
Get autocomplete suggestions for a prefix.

**Request:**
```json
{
  "prefix": "tri"
}
```

**Response:**
```json
["tries", "trie", "trees", "tree", "triangular"]
```

### GET `/search?query=<term>`
Search for documents containing the query term.

**Response:**
```json
{
  "results": [
    {
      "title": "Tree Data Structures",
      "url": "https://cs.example.com/trees",
      "snippet": "...Tree structures are fundamental in computer science algorithms...",
      "score": 0.1234
    }
  ]
}
```

## Example Output

### Web Interface
- Clean, modern search interface with live autocomplete
- Results displayed with title, URL, snippet, and relevance score
- Clickable links to view full documents

### CLI Output
```
Searching for: 'trees'...

Found 3 result(s):

[1] Tree Data Structures
    Document ID: 8
    File: data/doc_08.txt
    Relevance Score: 0.1234
      - Term Frequency: 0.0456
      - Authority Score: 0.0778
```

---

**Project for CS622 Discrete Mathematics**  
Demonstrating practical applications of data structures and algorithms.
